DB에서의 프로그래밍 제어문
 - 일반 쿼리에서는 사용할 수 없고, 프로시저나 함수 내부에서 사용됨

1. 변수
 - 프로시저 내에서 변수를 따로 선언하고 값을 넣어 사용할 수 있음
 - 선언법
declare 변수명 자료형[default 초기값]; -- 변수의 초기화도 선언과 함께 할 수도 있음
 - 값설정1 : set 변수명 = 값;
 - 값설정2 : select 컬럼명 into 변수명 from 테이블명[ where 조건 등...];
	-- 테이블에 있는 특정 컬럼의 값을 변수에 저장할 수도 있음
 - 값설정3 : default 명령을 이용하여 변수 선언시 초기화 시킬 수 있음
 - 변수명은 자바와 같은 방식으로 짓는 것이 좋음

2. 분기문
 - 조건에 따라 특정 영역의 실행문을 실행시키는 제어문

2-1. if문
 - 가장 많이 사용되는 분기문으로 조건의 참, 거짓에 따라 실행할 실행문이 달라짐
 - 실행문이 두 명령 이상일 경우 begin과 end로 묶어 처리해야 함
 - 문법
if 조건1 then
begin
	실행문1
end;
[
elseif 조건2 then
begin
	실행문2
end;
...
elseif 조건n then
begin
	실행문n
end;
else
begin
	실행문
end;
]
end if;

2-2. case 문
 - 자바의 switch문과 비슷하나 조건을 입력할 수 있음
 - 문법
case
	when 조건1 then
		실행문1;
	when 조건2 then
		실행문2;
	...
	when 조건n then
		실행문n;
	else
		모든 조건이 거짓일 때 실행할 실행문;
end case;

3. 반복문
 - 조건을 주어 조건이 참인 동안 지정한 실행문을 반복하여 실행시키는 제어문
 - 레이블은 생략가능하나 iterate와 leave 명령을 사용하려면 필수임
 - iterate 명령
	자바의 continue와 비슷한 기능을 함
	레이블을 지정한 후 iterate를 실행하면 지정된 레이블로 이동함
 - leave 명령
 	자바의 break와 비슷한 기능을 함
	레이블을 지정한 후 leave를 실행하면 지정된 레이블의 반복문을 빠져나감

3-1. while 문
 - 자바의 while문과 동일하게 동작
 - 문법
[레이블 :]while (조건) do
	실행문;
end while;

3-2. loop 문
 - 기본적으로 무한루프이며 조건을 loop문 안에서 if를 이용하여 입력하고, leave 명령을 이용해 반복문을 빠져나옴
 - 문법
레이블 : loop
	실행문;
	if 루프를 끝낼 조건 then
		leave 레이블;
	end if;
end loop;

3-3. repeat-until 문
 - 문법
repeat
	실행문;
	until 반복을 끝낼 조건 -- 조건이 참이면 반복문 종료(';' 없음)
	-- until 절은 반드시 repeat 문의 가장 아래에 위치시켜야 함
end repeat;

스토어드 프로시저(Stored Procedure)
 - DB의 객체들 중 하나로 저장 프로시저라고도 함
 - DBMS에서 제공하는 프로그래밍 기능으로 일반적은 프로그래밍과는 다르지만 DBMS 내에서 사용됨
 - 스토어드 프로시저는 퀴리문들의 집합으로 어떠한 동작을 일괄처리하기 위한 용도로 사용됨
 - 또는 자주 사용되는 일반적인 쿼리를 사용시 마다 다시 입력하여 사용하기 보다는 이것을 모듈화 시켜서 필요할 때마다 호출만 하면 되도록 만든 것을 의미

 - 사이트 제작 시 스토어드 프로시저를 사용했을 때 생기는 장점
 	자바에서는 스토어드 프로시저를 호출만 하고, 실제 실행은 DB에서 함으로 웹서버가 아닌 DB서버에서 작업이 이루어져 웹서버의 부담을 덜어주어 사이트 전반적인 속도가 향상됨
	쿼리의 제작을 자바가 아닌 DB에서 하므로 보안상 뛰어남

 - 단점
 	프로젝트 초기에 스토어드 프로시저를 먼저 생성해야 하기 때문에 초반 작업이 늘어남
	필요한 기능을 가진 스토어드 프로시저를 만들기 위해 미리 기능에 대한 이해가 있어야 함

 - 스토어드 프로시저 생성법
drop procedure if exists 프로시저명;
-- 프로시저 생성이 아닌 삭제 명령으로 프로시저를 수정하지 않고 삭제 후 재생성하기 위한 명령

delimiter $$
-- 명령의 종료 표시를 ';'이 아닌 '$$'로 임시 변경한다는 의미
create procedure 프로시저명([in 또는 out 매개변수(들)])
-- 지정한 이름의 프로시저를 현 DB에 생성하겠다는 의미(프로시저명은 보통 'sp_'로 시작함)
-- 매개변수는 없을 수도 있으며, 있는 경우 값을 받아오는 매개변수(in)과 값을 내보내는 매개변수(out)으로 나뉨
begin
-- 스토어드 프로시저의 시작을 의미
	프로시저의 내용으로 쿼리와 프로그래밍이 들어갈 영역이며 여러 개의 쿼리를 사용해도 됨
end $$
-- 스토어드 프로시저의 종료를 의미($$로 명령의 종료를 표시)
delimiter ;
-- 명령의 종료 표시를 다시 ';'로 되돌린다는 의미(마지막 띄어쓰기 유의)

 - 실행법 : call 프로시저명([인수(들)]);
 - 삭제법 : drop procedure 프로시저명;

스토어드 함수(Stored Function)
 - 사용자가 직접 만들어서 사용하는 함수로 그냥 함수나 사용자 정의 함수라고도 함
 - 스토어드 프로시저에 비해 사용빈도가 낮은 편으로 사용여부는 상황에 맞게 판단하면 됨
 - 함수는 무조건 리턴값이 존재해야 함
 - 매개변수는 in과 out의 구분없이 무조건 in에 해당하는 값을 받아오는 역할을 함
 - 스토어드 프로시저에서는 select문을 사용할 수 있지만 함수에서는 불가
 	이유는 select문의 실행결과는 여러 값의 집합으로 리턴할 수 없기 때문에 함수에서는 사용 불가
	단, select ... into 문은 집합을 리턴하는 것이 아니므로 사용가능
 - 스토어드 프로시저는 여러 쿼리문의 실행이나 계산 등의 작업에 사용되지만, 함수는 어떤 계산을 통해 하나의 값을
 받아오는 용도로만 사용
 - 스토어드 프로시저나 일반 쿼리문에서도 함수를 호출할 수 있음(select나 where절에 포함 가능)

 - 생성법
set global log_bin_trust_function_creators = 1;
-- 함수 생성을 위해 현재 로그인한 사용자에게 함수 생성 권한을 줌
 
drop function if exists 함수명;
-- 함수 생성이 아닌 삭제 명령으로 함수를 수정하지 않고 삭제 후 재생성하기 위한 명령

delimiter $$
-- 명령의 종료 표시를 ';'이 아닌 '$$'로 임시 변경한다는 의미
create function 함수명([매개변수(들)]) returns 리턴할 데이터의 자료형
-- 지정한 이름의 프로시저를 현 DB에 생성하겠다는 의미(프로시저명은 보통 'fn_'로 시작함)
begin
-- 함수의 시작을 의미
	함수의 내용;
	return 리턴값;
end $$
-- 함수의 종료를 의미($$로 명령의 종료를 표시)
delimiter ;
-- 명령의 종료 표시를 다시 ';'로 되돌린다는 의미(마지막 띄어쓰기 유의)

 - 실행법 : select 함수명([매개변수(들)]);
 - 삭제법 : drop function 함수명;

트리거(Trigger)
 - 특정 테이블에서 무슨 일이 발생하면 자동으로 지정해 놓은 작업이 실행되게 하는 기능
 	테이블의 입력, 수정, 삭제 중 하나가 발생하면 지정한 트리거에 의해 특정 작업이 실행됨
 - 트리거는 특정 테이블에 부착(attach)되는 SQL 프로그램 코드라고 생각하면 됨
 - 뷰(view)에는 트리거를 장착할 수 없음(장착 가능한 DBMS도 있음)
 - 프로시저와 비슷한 방식으로 생성하나 프로시저와는 다르게 독립적으로 실행시킬 수 없고, 오직 해당 테이블에 특정 이벤트가 발생할 경우에만 실행됨(매개변수도 사용할 수 없음)
 - DBMS의 기능들 중 메모리를 가장 많이 차지하는 기능으로 꼭 필요한 기능이 아니면 프로시저 등으로 돌려서 작업하는 것이 좋다.
 - 종류 : after와 before로 특정 작업 전후로 트리거에서 지정한 작업이 동작하게 됨

 - 생성법
drop trigger if exists 트리거명;
-- 트리거 생성이 아닌 삭제 명령으로 함수를 수정하지 않고 삭제 후 재생성하기 위한 명령

delimiter $$
-- 명령의 종료 표시를 ';'이 아닌 '$$'로 임시 변경한다는 의미
create trigger 트리거명() {after | before} {insert | update | delete} on 테이블명 for each row
begin
	트리거의 내용;
end $$
delimiter ;

 - 삭제 : drop trigger 트리거명;
 - 트리거의 내용에는 해당 테이블에 대한 쿼리는 사용할 수 없음
 - 가장 많이 사용되는 형태는 백업으로 변경 또는 삭제 전의 데이터를 다른 테이블로 백업받는 형식으로 사용됨
 	기존의 데이터는 'old'라는 객체를 통해 받아올 수 있음(update와 delete일 때 사용가능)
	 - 예) old.컬럼명 => 변경 또는 삭제 전의 컬럼에 들어있던 값
	새로운 데이터는 'new'라는 객체를 통해 받아올 수 있음(update와 insert일 때 사용가능) 
	 - 예) new.컬럼명 => 변경 또는 삽입된 컬럼에 들어있는 새로운 값
 - 트리거 사용시 반드시 내용을 문서화하여 기록해둬야 함(유지 보수시 필요)