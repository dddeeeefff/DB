조인(join)
 - select 쿼리에서 사용하는 기능으로 두 개 이상의 테이블을 서로 묶어서 하나의 결과 집합으로 만들어 내는 기능
 - 조인을 사용하면 속도가 느려지지만 사용하지 않고 처리하려면 더 느려지므로 조인기능을 반드시 숙지해야 함

1. Inner Join
 - 내부 조인이라고도 하며 가장 많이 사용되는 조인으로 일반적으로 조인이라 하면 inner join을 의미함
 - 문법
select 가져올컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과2의결합조건;
또는
select 가져올컬럼(들) from 테이블1, 테이블2 where 테이블1과2의결합조건;

 - 가져올 컬럼이나 조건 등에서 사용할 컬럼들의 이름이 두 테이블 모두에 있을 수도 있으므로 테이블명.컬럼명의 방식으로 작업해야 하나 테이블명이 길 경우 번거로우므로 테이블 이름에 alias(별칭)을 붙여 사용하는 것이 일반적임

 - 결합조건에 사용될 컬럼들은 보통 관계를 맺지 않은 상태에도 가능하나 일반적으로 관계를 맺는 PK와 FK를 결합조건으로 사용함

 - 3개 이상의 케이블을 조인
select 가져올컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과2의결합조건 inner join 테이블3 on 테이블3과1또는2의결합조건;
또는
select 가져올컬럼(들) from 테이블1, 테이블2, 테이블3 where 테이블1과2의결합조건 and 테이블3과1또는2의결합조건;


2. Outer Join
 - 외부 조인이라고도 하며 조인의 조건에 만족하지 않는 레코드들도 포함시키는 조인 방법
 - 문법
select 가져올컬럼(들) from 테이블1 <left | right> [outer] join 테이블2 on 테이블1과2의결합조건;

 - left를 사용하면 왼쪽의 테이블인 테이블1의 레코드는 모두 출력하고, 테이블2는 결합 조건에 맞는 레코드만 출력
 - right를 사용하면 오른쪽의 테이블인 테이블2의 레코드는 모두 출력하고, 테이블1는 결합 조건에 맞는 레코드만 출력
 - outer 명령어는 생략이 가능하여 outer join을 left join이나 right join으로 부르기도 함


3. Cross Join
 - 조건없이 두 테이블의 모든 레코드를 출력하는 조인 방법
 - 문법
select 가져올컬럼(들) from 테이블1 cross join 테이블2;
또는
select 가져올컬럼(들) from 테이블1, 테이블2;
 - 조건이 없으므로 on이나 where절이 따로 필요없음
 - 실제로는 거의 사용하지 않음


4. Union
 - 조인은 아니고, 여러 쿼리의 결과를 합쳐서 하나의 결과로 출력하는 기능
 - 문법
select 쿼리1
union [all]
select 쿼리2
union
...
union
select 쿼리n;
 - 사용시 각 쿼리에서 추출하는 컬럼의 개수가 같아야 함(자료형은 달라도 됨)
 - union 없이 작업할 경우 쿼리의 개수만큼 ResultSet이 필요한 상황에서 하나의 ResultSet만으로 처리할 수 있게 됨

 - 각 쿼리의 결과를 따로 사용해야 할 경우 쿼리들 사이에 'select '-', ... , '-''등의 구분용 쿼리를 사용할 수도 있음


5. In, Not In 연산자
 - 특정 컬럼의 값이 지정한 목록에 있는지 없는지에 따라 출력할 레코드를 선택하는 기능
 - 문법
select 컬럼(들) from 테이블 where 컬럼명 in (비교값1, 비교값2, ... , 비교값n);
	-- 컬럼의 값들 중 목록에 동일한 값이 있으면 출력
select 컬럼(들) from 테이블 where 컬럼명 not in (비교값1, 비교값2, ... , 비교값n);
	-- 컬럼의 값들 중 목록에 동일한 값이 없으면 출력

 - 괄호 안에는 비교 가능한 값들을 쉼표로 넣거나 서브 쿼리를 이용하여 select 해올 수 있음
 - 서브쿼리 문법
select 컬럼(들) from 테이블 where 컬럼명 in (select 비교할컬럼 from 테이블[where 조건]);
	-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 있으면 출력
select 컬럼(들) from 테이블 where 컬럼명 not in (select 비교할컬럼 from 테이블[where 조건]);
	-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 없으면 출력

※ 서브쿼리
 - 괄호로 묶어서 사용하며 항상 select 문으로 서브쿼리를 작성해야 함
 - 사용되는 쿼리
 	select 문에서는 어디서든 사용가능
	insert 문에서는 values 절에서 사용가능
	update 문에서는 set 절에서 사용가능
 - join 보다도 속도가 느리므로 사용시 주의해야 함


인덱스(Index)
 - 검색속도 향상을 위해 사용하는 기능으로 검색이 이루어지는 특정 컬럼에 장착하여 사용함

 - 장점
 	검색속도가 빨라짐(단, 항상 빨라지는 것은 아님)
	속도가 빨리지므로 쿼리의 실행시간이 줄어들어 전체 시스템(프로그램 or 사이트)의 성능이 향상됨

 - 단점
 	인덱스가 DB의 공간을 일정부분 차지하게 되어 DB의 전체 크기가 커짐
	 - 일반적으로 DB의 10%정도 추가 공간이 필요하게 됨
	처음 인덱스를 생성하는데 시간이 많이 소요될 수 있음
	데이터의 변경 작업(insert, update, delete)이 자주 일어날 경우 오히려 성능(전체적인 시스템 성능)이 나빠질 수도 있음
	검색결과가 너무 많이 나오는 컬럼은 인덱스를 장착하는 것이 오히려 느려지게 함

 - 인덱슨느 클러스터 인덱스(Clustered Index)와 보조 인덱스(Secondery Index)로 나뉨
 	보조 인덱스는 비클러스터 인덱스(Non Clustered Index)라고도 함

 - 클러스터 인덱스는 테이블당 하나만 생성이 가능하며, 보조 인덱스는 여러 개를 생성할 수 있음
 	클러스터 인덱스는 거의 primary key와 동일한 의미로 사용됨
	 - show index from 테이블명 쿼리로 확인 가능
	기본적으로 테이블의 데이터들은 primary key로 지정된 컬럼의 값에 따라 오름차순 정렬됨

 - 보조 인덱스는 특정 컬럼에 unique 제약조건을 걸면 생성됨(여러 개 생성 가능)
 	보조 인덱스가 걸린 컬럼에 not null 제약조건을 추가하면 자동으로 클러스터 인덱스로 지정됨(단, primary key가 없을 경우에만 가능)
	보조 인덱스가 없어도 정렬은 여전히 primary key를 기준으로 정렬됨

인덱스를 생성하거나 생성하지 않아야 하는 경우
 - where 절에서 조건으로 자주 사용되는 컬럼에는 인덱스를 걸어주는 것이 좋다.
 	단, 자주 사용되야 하며 검색결과가 적을수록 효과가 높음

 - 데이터의 중복도가 높은 컬럼은 인덱스를 생성해도 큰 효과가 없음

 - 외래키(FK)를 지정한 컬럼에는 인덱스가 자동으로 생성됨

 - join의 결합조건에 자주 사용되는 컬럼에는 인덱스를 생성해 주는 것이 좋음
	
 - insert/update/delete 가 얼마나 자주 일어나는지 고려해야 함
 	자주 일어나면 인덱스를 생성하는 것이 오히려 속도저하를 가져올 수 있음

 - 클러스터 인덱스가 아예 없는 것이 좋은 경우도 있음
 	PK를 지정하지 않고 보조 인덱스에도 not null을 지정하지 않으면 클러스터 인덱스가 없는 상태로 테이블이 생성됨
	insert/update/delete 가 자주 일어나는 테이블의 경우 PK가 아예 없는 것이 나을 수 있음
	예) 이벤트 진행시 갑자기 회원이 몰리는 상황 등을 의미
	PK 대신 일련번호(auto_increment)를 지정하는 경우도 많음

인덱스 생성 문법
create index 인덱스명 on 테이블명(인덱스를 장착할 컬럼명);

인덱스 삭제 문법
drop index 인덱스명 on 테이블명;